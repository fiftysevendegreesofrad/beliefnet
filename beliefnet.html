<!DOCTYPE>

<html>

	<head>
		<title>BeliefNet</title>

		<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1, maximum-scale=1">
		<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css">
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
		<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"></script>
	  
		<script src="https://unpkg.com/cytoscape/dist/cytoscape.min.js"></script>

		<!--polyfills are needed for this extension for old browsers like IE -->
		<script src="https://cdnjs.cloudflare.com/ajax/libs/core-js/2.5.7/shim.min.js"></script>

		<script src="https://unpkg.com/layout-base/layout-base.js"></script>
		<script src="https://unpkg.com/avsdf-base/avsdf-base.js"></script>
		<script src="https://unpkg.com/cytoscape-avsdf/cytoscape-avsdf.js"></script>

		<style>
			    /* Set height of the header */
				.header {
		height: 50px;
		background-color: #f1f1f1;
		text-align: center;
		line-height: 50px;
		}

	

    /* Set height of the left panel */
    .left-panel {
      /*height: 500px;*/
      background-color: #aaa;
    }

    /* Set height of the right panel */
    .right-panel {
      /*height: 500px;*/
      background-color: #bbb;
    }

	/* make modal-content narrow and centered on screen */
	.modal-content {
		width: 50%;
		margin: 0 auto;
		position: absolute;
		top: 50%;
		left: 50%;
		transform: translate(-50%, -50%);
		padding: 20px;
	}


			body {
				font-family: helvetica;
				font-size: 15px;
			}

			#cy {
				width: 100%;
				height: 100%;
				margin: 0 auto; /* Add this line to center the graph horizontally */
				display: block;
				justify-content: center; /* Add this line to center the graph horizontally */
				align-items: center; /* Add this line to center the graph vertically */
				z-index: 999;
				padding: 10%;
				box-sizing: border-box; /* Include padding in the total width and height */
  				overflow: visible; /* Prevent content from overflowing outside the container */
			}

			h1 {
				font-size: 2em;
				font-weight: bold;
			}
			h2 {
				font-size: 1.5em;
				font-weight: bold;
			}

			button {
				font-size: 15px;
				margin-right: 10px;
			}

			.line {
				clear:left;
				height:25px;
				margin-top:6px;
				margin-right:6px;
				margin-bottom:6px;
			}

			.radio {
				margin-left:25px;
			}

		</style>

		<script>
			let DEVMODE = true;
			let MINLOGPROB,MAXLOGPROB;
			let narrative = [];

			async function load_elements()
			{
				//let response = await fetch(new Request(filename));
				//let text = await response.text();
				let text=`
REPTILES 0.01: Reptilian Elite
The world is governed by a secret elite of literal reptiles - actual lizard people
The world is governed by humans
+5 QANON
+5 GOVERNMENTS
+5 CHEMTRAILS
+5 BIRDS
-10 HOPE

QANON 0.05: QAnon
Donald Trump's primary struggle is to fight against Satan worshipping paedophiles
Donald Trump's primary struggle is that he is Donald Trump
+5 CHEMTRAILS
+5 GOVERNMENTS

GOVERNMENTS 0.2: Governments
Governments are the tools of a secret evil world order
Governments are no more competent or moral than the rest of us 
Governments can be trusted 
+5 COMPETENT
+1 PHARMA

BIRDS 0.01: Birds
All birds have been replaced with robot surveillance drones
Birds are just birds
+5 GOVERNMENTS
+5 FIVEG

FIVEG 0.05: 5G
Disease is caused by 5G phone masts
Disease is caused by germs, viruses, etc
+5 CHEMTRAILS
+5 GOVERNMENTS
-5 HOPE

CHEMTRAILS 0.1: Chemtrails
Trails left behind jets are chemtrails used for mind control
Trails left behind jets are condensed water called contrails
+5 PHARMA
+5 GOVERNMENTS
-5 HOPE

PHARMA 0.5: Big Pharma
Big pharma is the tool of a secret world order
Big pharma does not always act in the interests of the patient 
Large medical research corporations are trustworthy
+1 IBSCURE
+5 HOMEOPATHY

HOMEOPATHY 0.3: Homeopathy
Homeopathy definitely works
Science has proven nothing about homeopathy, but one day it might
Homeopathy is indistinguishable from placebo, we're done here
+5 IBSCURE

COMPETENT 0.5: I got fired 
I got fired because the elite are trying to suppress me 
I got fired because my manager was incompetent
I got fired because I am incompetent 
+5 HOPE

IBSCURE 0.5: Irritable Bowel Syndrome 
My IBS can be cured
...well, maybe. I dunno.
My IBS is incurable
+5 HOPE
+5 HOMEOPATHY

HOPE 0.9: Hope
There is hope for me! 
There is no hope for me!

`
				let lines = text.split("\n");
				let elements = {nodes: [], edges: []};
				
				while (lines.length > 0)
				{
					let line = lines.shift();
					if (line.trim()=="") continue;

					//expecting node line
					let parts = line.split(":");
					let leftparts = parts[0].split(" ");
					let nodeLabel = leftparts[0].trim();
					let baseProb = parseFloat(leftparts[1]);
					let userLabel = parts[1].trim();

					let options=[]
					line = lines.shift();
					while (true)
					{
						if (line.trim()=="")
							break; //end of node
						if (line[0]=="+" || line[0]=="-")
							break; //that will be an edge
						options.push(line);
						line = lines.shift();
					}
					elements.nodes.push({data: {id: nodeLabel, label: userLabel, displaylabel: userLabel, baseProb: baseProb, options: options,
						predicateValue: 0, logprob: 0, researched: false}});

					//now we are expecting edges
					while(line.trim()!="")
					{
						let parts = line.split(" ");
						let weight = parseFloat(parts[0]);
						let source = parts[1].trim();
						elements.edges.push({data: {source: source, target: nodeLabel, weight: weight, absweight: Math.abs(weight), 
							directed: true, color:'grey'}});
						line = lines.shift();
					}
				}
				return elements;
			}
			function predicateToIndex(node)
			{
				return (1-node.data("predicateValue"))*(node.data("options").length-1);
			}
			function getPredicateFromIndex(node, index)
			{
				return 1-index/(node.options.length-1);
			}
			function updateEdgePredValuesGetNodeLogProb(n)
			{
				let baseProb = n.data("baseProb");
				let nodeLogOdds = Math.log(baseProb/(1-baseProb));
				let nodeCoeffValue = n.data("predicateValue")*2-1;
				for (e of n.incomers("edge"))
				{
					let sourcePredValue = e.source().data("predicateValue");
					let incomingCoeffValue = sourcePredValue*2-1;
					nodeLogOdds += incomingCoeffValue*e.data("weight");
					let nodeMutualSupport = incomingCoeffValue*nodeCoeffValue*Math.sign(e.data("weight"));
					if (nodeMutualSupport>0)
						e.data("color","green");
					else if (nodeMutualSupport<0)
						e.data("color","red");
					else
						e.data("color","grey");
				}
				nodeLogOdds *= nodeCoeffValue;
				return nodeLogOdds - Math.log(1+Math.exp(nodeLogOdds));
			}
			function computeBelievabilityFromLogLik(logLik)
			{
				let believability = (logLik-MINLOGPROB)/(MAXLOGPROB-MINLOGPROB)*100;
				//round to 1 decimal place
				return Math.round(believability*10)/10;
			}
			function updateBelievabilityDisplay(cy)
			{
				let believability = computeBelievabilityFromLogLik(updateLogLik(cy));
				console.log(believability);
				document.getElementById("loglik").innerHTML = believability;
				cy.resize();
			}
			function updateNarrativeDisplay()
			{
				html = "";
				for (let i=0;i<narrative.length;i++)
				{
					let message = narrative[i].message;
					let undo = narrative[i].undo;
					html += "<div class='line'><button onclick='revert("+undo+")'>Undo</button>"+message+"</div>";
				}
				document.getElementById("narrative").innerHTML = html;
			}
			function updateLogLik(cy)
			{
				let logLik = 0;
				for (n of cy.nodes())
				{
					let logProb = updateEdgePredValuesGetNodeLogProb(n);
					n.data("logprob",logProb);
					n.data("displaylabel",n.data("label"));
					logLik += logProb;
				}
				return logLik;
			}
			function altNetworkLogLik(cy,nodesToChange)
			{
				let eles = cy.elements().map(x=>x.json());
				let cyClone = cytoscape({elements: eles, headless: true});
				for (let [nodeID, nodePredValue] of Object.entries(nodesToChange))
					cyClone.getElementById(nodeID).data("predicateValue",nodePredValue);
				return updateLogLik(cyClone);
			}
			function getAllPredCombinations(nodes)
			{
				//recurse through all possible node predicate values
				let head = nodes[0];
				let tail = nodes.slice(1);
				let options = head.data("options");
				let optionsPredValues = [];
				for (let i=0; i<options.length; i++)
					optionsPredValues.push(getPredicateFromIndex(head.data(), i));

				let tailCombinations;
				if (tail.length>0)
					tailCombinations = getAllPredCombinations(tail);
				else
					tailCombinations = [[]];

				let result = [];
				for (optionIndex of optionsPredValues)
					for (tailCombination of tailCombinations)
						result.push([optionIndex].concat(tailCombination));
				return result;
			}
			function computeMinMaxLogProbs(cy)
			{
				let combinations;
				let recompute = false;
				if (recompute)
				{
					let nodes = cy.nodes();
					combinations = getAllPredCombinations(nodes);
					result = [];
					for (let i = 0;i<combinations.length;i++)
					{
						let nodesToChange = {};
						for (let j=0;j<nodes.length;j++)
							nodesToChange[nodes[j].id()] = combinations[i][j];
						result.push(altNetworkLogLik(cy,nodesToChange));
					}
				}
				else result=[-80.47512266156517,-0.32923266463987577];
				//get min and max values from result
				MINLOGPROB = Math.min(...result);
				MAXLOGPROB = Math.max(...result);
				if (recompute)
				{
					let maxIndex = result.indexOf(Math.max(...result));
					console.log(combinations[maxIndex]);
					console.log(MINLOGPROB,MAXLOGPROB);
				}
			}
			function updateGraphDisplay(cy)
			{
				let visibleNodes = cy.nodes(":visible");
				let layoutOptions = {
						name: 'avsdf',
						nodeSeparation: 120,
						animate: "end",
						animationDuration: 1000,
						animationEasing: 'ease-in-out',
						nodeSeparation: 120,
						eles:visibleNodes
					};
				cy.layout(layoutOptions).run();
			}
			document.addEventListener('DOMContentLoaded', async function(){

				let elements = await load_elements();
				
				var cy = window.cy = cytoscape({
					container: document.getElementById('cy'),



					style: [
						{
							selector: 'node',
							style: {
								'label': 'data(displaylabel)',
								'text-valign': 'center',
								'color': '#000000',
								'pie-1-background-color':'mapData(predicateValue, 0, 1, blue, purple)',
								'pie-1-background-size':'mapData(baseProb,0,1,0,100)',
								'pie-2-background-color':'mapData(predicateValue, 0, 1, #aaaaff, #ffaaff)',
								'pie-2-background-size':'mapData(baseProb,0,1,100,0)',
								'display':'none'
							}
						},
						{
							selector: 'node[predicateValue=0.5]',
							style: {
								'pie-1-background-color':'#444444',
								'pie-2-background-color':'#aaaaaa',
							}
						},
						
						{
							selector: 'edge',
							style: {
								'width': 'mapData(absweight, 0, 5, 0, 7)',
								'line-color': 'data(color)',
								'opacity': 0.5,
								'target-arrow-shape': 'triangle',
								'target-arrow-color': 'data(color)',
								'curve-style': 'bezier'
							}
						}
					],

					elements: elements,
					autounselectify: true,
					autoungrabify: true,
					userZoomingEnabled: false,
					userPanningEnabled: false
				});
				cy.nodes().first().style("display","element");
				updateGraphDisplay(cy);
				updateLogLik(cy); //call to initialize node logprobs
				computeMinMaxLogProbs(cy);
				updateBelievabilityDisplay(cy);

				cy.bind('click', 'node', function(evt) {
					let node = evt.target;
					displayNodeDetails(node);
				});

					function displayNodeDetails(node)
				{
					document.getElementById("topic").innerHTML=node.data("displaylabel");
					let options = node.data().options;
					let whichSelected = predicateToIndex(node);
					document.getElementById("currentBelief").innerHTML=options[whichSelected];

					//create research button
					document.getElementById("ResearchButton").innerHTML="";
					if (!node.data("researched"))
					{
						let button = document.createElement("button");
						button.innerHTML = "Research Related Beliefs";
						button.addEventListener("click", function(evt1){
							node.data("researched",true);
							//iterate through neighbouring nodes
							for (n of node.openNeighborhood("node"))
								n.style("display","element");
							displayNodeDetails(node);
							updateGraphDisplay(cy);
						});
						document.getElementById("ResearchButton").appendChild(button);
					}
					else
					{
						let p = document.createElement("ul");

						for (n of node.openNeighborhood("node"))
						{
							let weight = node.edgesWith(n).data("weight");
							if (weight>0) weight = "+"+weight;
							p.innerHTML += "<li>"+weight+": "+n.data("displaylabel")+"</li>";
						}
						document.getElementById("ResearchButton").appendChild(p);
					}
					//create buttons for other options
					document.getElementById("nodeDetails").innerHTML="";
					let prevNodeValues = cy.elements().map(x=>x.json()); //for undo not yet implemented
					let table = document.createElement("table");
					for (let i=0; i<options.length; i++)
					{
						if (i==whichSelected) continue;

						let row = document.createElement("tr");

						let optionSpan = document.createElement("span");
						optionSpan.innerHTML = options[i];

						let button = document.createElement("button");
						let buttonPredValue = getPredicateFromIndex(node.data(), i);
						button.innerHTML = "Influence";

						let resultingBelievability = computeBelievabilityFromLogLik(altNetworkLogLik(cy,{[node.id()]:buttonPredValue}));
						let minBelievability = computeBelievabilityFromLogLik(-6.1);
						
						let possible = resultingBelievability>minBelievability;
						
						if (possible)
						{
							if (DEVMODE)
									button.style.backgroundColor = "green";
							button.addEventListener("click", function(evt1){
								node.data("predicateValue",buttonPredValue); 
								narrative.push({message:options[i], undo:prevNodeValues});
								updateBelievabilityDisplay(cy);
								updateNarrativeDisplay();
								displayNodeDetails(node);
							});
						}
						else
						{
							if (DEVMODE)
									button.style.backgroundColor = "red";
							button.addEventListener("click", function(evt1){
								//make modal popup
								let modal = document.getElementById("myModal");
								let span = document.getElementsByClassName("close")[0];
								modal.style.display = "block";
								span.onclick = function() {
									modal.style.display = "none";
								}
								window.onclick = function(event) {
									if (event.target == modal) {
										modal.style.display = "none";
									}
								}
								
							});
						}

						let td = document.createElement("td");
						td.appendChild(button);
						row.appendChild(td);
						let td2 = document.createElement("td");
						td2.appendChild(optionSpan);
						row.appendChild(td2);
						table.appendChild(row);
					}
					document.getElementById("nodeDetails").appendChild(table);
				}


			});
		</script>
	</head>

	<body>
		<div class="header">
			<h1>Narrative Believability: <span id="loglik"/></h1>
		</div>
		
		<!-- Panels -->
		<div class="row">
		<div class="col-sm-3 left-panel">
			<h1 id="topic"></h1>
			<h2>Subject's Current Belief:</h2>
			<ul>
			<li id="currentBelief"></li>
			</ul>
			<h2>Alternative Beliefs:</h2>
			<p id="nodeDetails"></p>
			<h2>Subject's Related Beliefs:</h2>
			<div id="ResearchButton"></div>
		</div>
		<div class="col-sm-6">
			<div id="cy"></div>
		</div>
		<div class="col-sm-3 right-panel">
			<h1>Narrative</h1>
			<div id="narrative"></div>
		</div>
		</div>
		
		<div id="myModal" class="modal">
			<div class="modal-content">
				<span class="close">&times;</span>
				<p>They don't buy it.</p>
			</div>
		</div>
		
		
	</body>

</html>
